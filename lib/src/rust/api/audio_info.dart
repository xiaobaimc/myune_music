// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These functions are ignored because they are not marked as `pub`: `read_tagged_file`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`

Future<AudioInfo> readAudioInfo({
  required String path,
  required AudioInfoOptions options,
}) => RustLib.instance.api.crateApiAudioInfoReadAudioInfo(
  path: path,
  options: options,
);

class AudioInfo {
  final String? title;
  final String? artist;
  final String? album;
  final Uint8List? cover;
  final String? lyrics;
  final BigInt? durationMs;
  final int? bitrate;
  final int? sampleRate;
  final int? year;
  final String? genre;
  final String? albumArtist;

  const AudioInfo({
    this.title,
    this.artist,
    this.album,
    this.cover,
    this.lyrics,
    this.durationMs,
    this.bitrate,
    this.sampleRate,
    this.year,
    this.genre,
    this.albumArtist,
  });

  @override
  int get hashCode =>
      title.hashCode ^
      artist.hashCode ^
      album.hashCode ^
      cover.hashCode ^
      lyrics.hashCode ^
      durationMs.hashCode ^
      bitrate.hashCode ^
      sampleRate.hashCode ^
      year.hashCode ^
      genre.hashCode ^
      albumArtist.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioInfo &&
          runtimeType == other.runtimeType &&
          title == other.title &&
          artist == other.artist &&
          album == other.album &&
          cover == other.cover &&
          lyrics == other.lyrics &&
          durationMs == other.durationMs &&
          bitrate == other.bitrate &&
          sampleRate == other.sampleRate &&
          year == other.year &&
          genre == other.genre &&
          albumArtist == other.albumArtist;
}

class AudioInfoOptions {
  final bool needCover;
  final bool needLyrics;
  final bool needAudioProps;
  final bool needExtraTags;

  const AudioInfoOptions({
    required this.needCover,
    required this.needLyrics,
    required this.needAudioProps,
    required this.needExtraTags,
  });

  static Future<AudioInfoOptions> default_() =>
      RustLib.instance.api.crateApiAudioInfoAudioInfoOptionsDefault();

  @override
  int get hashCode =>
      needCover.hashCode ^
      needLyrics.hashCode ^
      needAudioProps.hashCode ^
      needExtraTags.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is AudioInfoOptions &&
          runtimeType == other.runtimeType &&
          needCover == other.needCover &&
          needLyrics == other.needLyrics &&
          needAudioProps == other.needAudioProps &&
          needExtraTags == other.needExtraTags;
}
